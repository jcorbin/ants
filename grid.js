// Generated by CoffeeScript 1.3.3
(function() {
  var root, _base, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if ((_ref = (_base = (root = typeof exports !== "undefined" && exports !== null ? exports : this)).Ants) == null) {
    _base.Ants = {};
  }

  root.Ants.GridData = (function() {

    GridData.MaxGrowStep = 512;

    function GridData(shape, initValue) {
      this.initValue = initValue;
      if (shape.length !== 2) {
        throw Error("unsupported Grid dimensonality " + shape.length);
      }
      this.shape = shape;
      this.view = [0, 0, this.shape[0], this.shape[1]];
      this.reset();
    }

    GridData.prototype.reset = function() {
      var i, size, _i, _results;
      size = this.shape[0] * this.shape[1];
      this._data = new Int8Array(size);
      _results = [];
      for (i = _i = 0; 0 <= size ? _i < size : _i > size; i = 0 <= size ? ++_i : --_i) {
        _results.push(this._data[i] = this.initValue);
      }
      return _results;
    };

    GridData.prototype.index = function(pos) {
      var col, row;
      row = pos[0] + this.view[0];
      col = pos[1] + this.view[1];
      return row * this.shape[1] + col;
    };

    GridData.prototype.get = function(pos) {
      return this._data[this.index(pos)];
    };

    GridData.prototype.set = function(pos, val) {
      return this._data[this.index(pos)] = val;
    };

    GridData.prototype.each = function(f) {
      var col, pos, row, _i, _ref1, _results;
      _results = [];
      for (row = _i = 0, _ref1 = this.view[2]; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; row = 0 <= _ref1 ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref2, _results1;
          _results1 = [];
          for (col = _j = 0, _ref2 = this.view[3]; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; col = 0 <= _ref2 ? ++_j : --_j) {
            pos = [row, col];
            _results1.push(f(pos, this._data[this.index(pos)]));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    GridData.prototype.grow = function(growStep) {
      var begin, end, newdata, newshape, offset, row, _i, _j, _k, _l, _m, _ref1, _ref2, _ref3, _ref4, _ref5;
      growStep = Math.max(growStep, Math.min(root.Ants.GridData.MaxGrowStep, Math.max.apply(Math, this.shape) * 2));
      newshape = [this.shape[0] + growStep * 2, this.shape[1] + growStep * 2];
      newdata = new Int8Array(newshape[0] * newshape[1]);
      for (offset = _i = 0, _ref1 = growStep * newshape[1]; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; offset = 0 <= _ref1 ? ++_i : --_i) {
        newdata[offset] = this.initValue;
      }
      for (row = _j = 0, _ref2 = this.shape[0]; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; row = 0 <= _ref2 ? ++_j : --_j) {
        for (offset = _k = offset, _ref3 = offset + growStep; offset <= _ref3 ? _k < _ref3 : _k > _ref3; offset = offset <= _ref3 ? ++_k : --_k) {
          newdata[offset] = this.initValue;
        }
        begin = row * this.shape[1];
        end = begin + this.shape[1];
        newdata.set(this._data.subarray(begin, end), offset);
        offset += this.shape[1];
        for (offset = _l = offset, _ref4 = offset + growStep; offset <= _ref4 ? _l < _ref4 : _l > _ref4; offset = offset <= _ref4 ? ++_l : --_l) {
          newdata[offset] = this.initValue;
        }
      }
      for (offset = _m = offset, _ref5 = offset + growStep * newshape[1]; offset <= _ref5 ? _m < _ref5 : _m > _ref5; offset = offset <= _ref5 ? ++_m : --_m) {
        newdata[offset] = this.initValue;
      }
      this._data = newdata;
      this.shape = newshape;
      this.view[0] += growStep;
      return this.view[1] += growStep;
    };

    GridData.prototype.resizeBy = function(delta) {
      var above, below, growStep, leftof, rightof, spare_above, spare_below, spare_leftof, spare_rightof;
      if (delta.length !== this.shape.length * 2) {
        throw Error("Need " + (this.shape.length * 2) + " deltas, got " + delta.length);
      }
      above = delta[0], below = delta[1], leftof = delta[2], rightof = delta[3];
      spare_above = this.view[0];
      spare_below = this.shape[0] - this.view[2] - this.view[0];
      spare_leftof = this.view[1];
      spare_rightof = this.shape[1] - this.view[3] - this.view[1];
      growStep = Math.max(0, above - spare_above, below - spare_below, leftof - spare_leftof, rightof - spare_rightof);
      if (growStep > 0) {
        this.grow(growStep);
      }
      this.view[0] -= above;
      this.view[1] -= leftof;
      this.view[2] += above + below;
      return this.view[3] += leftof + rightof;
    };

    return GridData;

  })();

  root.Ants.Grid = (function(_super) {
    var colorGenerator, cols, rows;

    __extends(Grid, _super);

    Grid.frozenMethod = function(f) {
      return function() {
        var old, r;
        old = this.frozen;
        this.frozen = true;
        r = f.apply(this, arguments);
        this.frozen = old;
        if (this.needsSizeUpdate) {
          this.updateSize();
        } else {
          this.render();
        }
        return r;
      };
    };

    Grid.HueWheelGenerator = function(s, l) {
      s = (s * 100).toFixed(1) + '%';
      l = (l * 100).toFixed(1) + '%';
      return function(ncolors) {
        var i, _i, _ref1, _results;
        _results = [];
        for (i = _i = 0, _ref1 = ncolors - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          _results.push("hsl(" + (Math.floor(360 * i / ncolors)) + ", " + s + ", " + l + ")");
        }
        return _results;
      };
    };

    rows = 50;

    cols = 50;

    colorGenerator = Grid.HueWheelGenerator(0.75, 0.4);

    function Grid(canvas, rows, cols, colorGenerator) {
      this.canvas = canvas;
      if (colorGenerator != null) {
        this.colorGenerator = colorGenerator;
      }
      this.colors = this.colorGenerator(2);
      this.newCellValue = -2;
      if (rows != null) {
        this.rows = rows;
      }
      if (cols != null) {
        this.cols = cols;
      }
      this.ants = [];
      this.initial_state = [this.rows, this.cols];
      this.frozen = false;
      this.needsSizeUpdate = false;
      this.reset();
      this.running = null;
      this.runDelay = 64;
      this.runSteps = 1;
      window.addEventListener('resize', this.updateSize.bind(this), false);
    }

    Grid.prototype.getCell = function(x, y) {
      var v;
      v = this.data.get([x, y]);
      while (v < 0) {
        v += this.colors.length;
      }
      return v;
    };

    Grid.prototype.setCell = function(x, y, v) {
      var pos;
      pos = [x, y];
      if (this.data.get(pos) !== v) {
        this.data.set(pos, v);
        return this.drawCell(x, y);
      }
    };

    Grid.prototype.setColorGenerator = function(generator) {
      this.colorGenerator = generator;
      this.colors = this.colorGenerator(this.colors.length);
      return this.render();
    };

    Grid.prototype.removeColor = function(index) {
      var ant, _i, _len, _ref1;
      this.colors = this.colorGenerator(this.colors.length - 1);
      this.newCellValue += 1;
      _ref1 = this.ants;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        ant = _ref1[_i];
        ant.turns.splice(index, 1);
        ant.dispatch('turnsChanged');
      }
      return this.reset();
    };

    Grid.prototype.addColor = function(index) {
      var ant, ncolors, _i, _len, _ref1;
      ncolors = this.colors.length + 1;
      this.colors = this.colorGenerator(ncolors);
      this.newCellValue -= 1;
      _ref1 = this.ants;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        ant = _ref1[_i];
        while (ant.turns.length < ncolors) {
          ant.turns.push(root.Ants.Ant.TurnLeft);
        }
        ant.dispatch('turnsChanged');
      }
      return this.reset();
    };

    Grid.prototype.setNumColors = function(n) {
      var ant, _i, _len, _ref1;
      if (this.colors.length === n) {
        return;
      }
      this.newCellValue = -n;
      this.colors = this.colorGenerator(n);
      _ref1 = this.ants;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        ant = _ref1[_i];
        if (ant.turns.length !== n) {
          if (ant.turns.length > n) {
            ant.turns.splice(n - 1);
          } else {
            while (ant.turns.length < n) {
              ant.turns.push(root.Ants.Ant.TurnLeft);
            }
          }
          ant.dispatch('turnsChanged');
        }
      }
      return this.reset();
    };

    Grid.prototype.runStep = function() {
      return this.step(this.runSteps);
    };

    Grid.prototype.play = function() {
      if (this.running != null) {
        return;
      }
      this.running = setInterval(this.runStep.bind(this), this.runDelay);
      return this.dispatch('play');
    };

    Grid.prototype.stop = function() {
      if (!(this.running != null)) {
        return;
      }
      clearInterval(this.running);
      this.running = null;
      return this.dispatch('stop');
    };

    Grid.prototype.runFaster = function(factor) {
      if (this.runDelay > 1) {
        this.runDelay /= factor;
      } else {
        this.runSteps *= factor;
      }
      if (this.running != null) {
        clearInterval(this.running);
        return this.running = setInterval(this.runStep.bind(this), this.runDelay);
      }
    };

    Grid.prototype.runSlower = function(factor) {
      if (this.runSteps > 1) {
        this.runSteps /= factor;
      } else {
        this.runDelay *= factor;
      }
      if (this.running != null) {
        clearInterval(this.running);
        return this.running = setInterval(this.runStep.bind(this), this.runDelay);
      }
    };

    Grid.prototype.reset = Grid.frozenMethod(function() {
      var ant, _i, _len, _ref1;
      this.rows = this.initial_state[0];
      this.cols = this.initial_state[1];
      this.data = new root.Ants.GridData([this.rows, this.cols], this.newCellValue);
      this.iteration = 0;
      _ref1 = this.ants;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        ant = _ref1[_i];
        ant.reset();
      }
      this.updateSize();
      return this.dispatch('reset');
    });

    Grid.prototype.corners = function() {
      return [[0, 0], [0, this.rows - 1], [this.cols - 1, this.rows - 1], [this.cols - 1, 0]];
    };

    Grid.prototype.resize = function(rows, cols) {
      var dc, dr;
      dc = (cols - this.cols) / 2;
      dr = (rows - this.rows) / 2;
      return this.resizeBy(Math.floor(dc), Math.ceil(dc), Math.floor(dr), Math.ceil(dr));
    };

    Grid.prototype.resizeBy = function(leftof, rightof, above, below) {
      var ant, _i, _len, _ref1;
      this.data.resizeBy([above, below, leftof, rightof]);
      this.rows += above + below;
      this.cols += leftof + rightof;
      _ref1 = this.ants;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        ant = _ref1[_i];
        ant.row += above;
        ant.col += leftof;
        ant.getInBounds();
      }
      return this.updateSize();
    };

    Grid.prototype.updateSize = function() {
      var ctx;
      if (this.frozen) {
        this.needsSizeUpdate = true;
        return;
      }
      this.scale = Math.min(this.canvas.parentNode.clientWidth / this.cols, this.canvas.parentNode.clientHeight / this.rows);
      this.canvas.width = this.cols * this.scale;
      this.canvas.height = this.rows * this.scale;
      ctx = this.canvas.getContext('2d');
      ctx.scale(this.scale, this.scale);
      if (this.needsSizeUpdate) {
        this.needsSizeUpdate = false;
      }
      return this.render();
    };

    Grid.prototype.randomize = function() {
      var i, j, _i, _ref1, _results;
      _results = [];
      for (i = _i = 0, _ref1 = this.rows; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref2, _results1;
          _results1 = [];
          for (j = _j = 0, _ref2 = this.cols; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; j = 0 <= _ref2 ? ++_j : --_j) {
            _results1.push(this.data.set([i, j], Math.random() * this.colors.length));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Grid.prototype.drawCell = function(row, col) {
      var color, ctx;
      if (this.frozen) {
        return;
      }
      color = this.getCell(row, col);
      color = this.data.get([row, col]);
      if (color < 0) {
        return;
      }
      color = this.colors[color];
      ctx = this.canvas.getContext('2d');
      ctx.fillStyle = color;
      return ctx.fillRect(col, row, 1, 1);
    };

    Grid.prototype.render = function() {
      var ant, ctx, _i, _len, _ref1, _results,
        _this = this;
      ctx = this.canvas.getContext('2d');
      this.data.each(function(pos, val) {
        return _this.drawCell.apply(_this, pos);
      });
      _ref1 = this.ants;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        ant = _ref1[_i];
        _results.push(ant.draw());
      }
      return _results;
    };

    Grid.prototype.addAnt = function(ant) {
      this.ants.push(ant);
      ant.grid = this;
      return ant.reset();
    };

    Grid.prototype.isInBounds = function(row, col) {
      return (0 <= row && row < this.rows) && (0 <= col && col < this.cols);
    };

    Grid.prototype.step = function(n) {
      var ant, i, _i, _j, _len, _ref1;
      for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
        _ref1 = this.ants;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          ant = _ref1[_j];
          ant.step();
        }
      }
      this.iteration += n;
      return this.dispatch('step');
    };

    Grid.prototype.setIteration = Grid.frozenMethod(function(i) {
      if (i === this.iteration) {
        return;
      }
      if (i < this.iteration) {
        throw Error('unimplemented: rewinding simulation');
      }
      return this.step(i - this.iteration);
    });

    return Grid;

  })(root.EventDispatcher);

}).call(this);
