// Generated by CoffeeScript 1.3.3
(function() {
  var HalfPI, Left, Right, TwoPI, closestPoint, root, _base, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if ((_ref = (_base = (root = typeof exports !== "undefined" && exports !== null ? exports : this)).Ants) == null) {
    _base.Ants = {};
  }

  closestPoint = function(ref, points) {
    var cur, point, pq, q, _i, _len;
    cur = null;
    q = 0;
    for (_i = 0, _len = points.length; _i < _len; _i++) {
      point = points[_i];
      pq = Math.pow(ref[0] - point[0], 2) + Math.pow(ref[1] - point[1], 2);
      if (cur === null || pq < q) {
        cur = point;
        q = pq;
      }
    }
    return cur;
  };

  Right = 1;

  Left = 0;

  HalfPI = Math.PI / 2;

  TwoPI = 2 * Math.PI;

  root.Ants.Ant = (function(_super) {

    __extends(Ant, _super);

    Ant.DefaultTurns = "RL";

    Ant.TurnLeft = Left;

    Ant.TurnRight = Right;

    Ant.Turn2Name = function(turn) {
      switch (turn) {
        case Right:
          return 'Right';
        case Left:
          return 'Left';
        default:
          throw Error("Invalid turn " + turn);
      }
    };

    Ant.Name2Turn = function(name) {
      switch (name.toLowerCase()) {
        case 'right':
          return Right;
        case 'left':
          return Left;
        default:
          throw Error("Invalid turn name " + turn);
      }
    };

    Ant.prototype.row = null;

    Ant.prototype.col = null;

    Ant.prototype.heading = 0;

    Ant.prototype.color = '#f00';

    Ant.prototype.initial_state = null;

    function Ant(row, col, heading, color, turns) {
      if (row != null) {
        this.row = row;
      }
      if (col != null) {
        this.col = col;
      }
      if (heading != null) {
        this.heading = heading;
      }
      if (color != null) {
        this.color = color;
      }
      this.setTurnString(turns != null ? turns : Ant.DefaultTurns);
      if ((this.row != null) && (this.col != null)) {
        this._saveInitialState();
      }
    }

    Ant.prototype.getTurnString = function() {
      var turn;
      return ((function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.turns;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          turn = _ref1[_i];
          _results.push(Ant.Turn2Name(turn)[0].toUpperCase());
        }
        return _results;
      }).call(this)).join('');
    };

    Ant.prototype.setTurnString = function(s) {
      var c, i;
      s = s.toLowerCase();
      if (this.turns && s === this.getTurnString().toLowerCase()) {
        return;
      }
      this.turns = (function() {
        var _i, _len, _results;
        _results = [];
        for (i = _i = 0, _len = s.length; _i < _len; i = ++_i) {
          c = s[i];
          switch (c) {
            case 'r':
              _results.push(Right);
              break;
            case 'l':
              _results.push(Left);
              break;
            default:
              throw Error('Invalid turn direction');
          }
        }
        return _results;
      })();
      this.dispatch('turnsChanged');
      if (this.grid != null) {
        if (this.grid.length === this.turns.length) {
          return this.grid.reset();
        } else {
          return this.grid.setNumColors(this.turns.length);
        }
      }
    };

    Ant.prototype._saveInitialState = function() {
      return this.initial_state = [this.row, this.col, this.heading];
    };

    Ant.prototype.reset = function() {
      var _ref1;
      if (this.initial_state) {
        this.grid.drawCell(this.row, this.col);
        _ref1 = this.initial_state, this.row = _ref1[0], this.col = _ref1[1], this.heading = _ref1[2];
      }
      this.getInBounds();
      return this.draw();
    };

    Ant.prototype.draw = function() {
      var ctx;
      if (this.grid.frozen) {
        return;
      }
      ctx = this.grid.canvas.getContext('2d');
      ctx.fillStyle = this.color;
      return ctx.fillRect(this.col + 0.25, this.row + 0.25, 0.5, 0.5);
    };

    Ant.prototype.step = function() {
      var above, below, c, leftof, rightof;
      c = this.grid.getCell(this.row, this.col);
      this.grid.setCell(this.row, this.col, (c + 1) % this.grid.colors.length);
      this.heading = ((function() {
        switch (this.turns[c]) {
          case Right:
            return this.heading + HalfPI;
          case Left:
            return this.heading - HalfPI;
        }
      }).call(this)) % TwoPI;
      this.col += Math.round(Math.cos(this.heading));
      this.row += Math.round(Math.sin(this.heading));
      if (!this.grid.isInBounds(this.row, this.col)) {
        leftof = rightof = above = below = 0;
        if (this.row < 0) {
          above = 0 - this.row;
        } else if (this.row >= this.grid.rows) {
          below = this.grid.rows - this.row + 1;
        }
        if (this.col < 0) {
          leftof = 0 - this.col;
        } else if (this.col >= this.grid.cols) {
          rightof = this.grid.cols - this.col + 1;
        }
        this.grid.resizeBy(leftof, rightof, above, below);
      }
      return this.draw();
    };

    Ant.prototype.getInBounds = function() {
      var t;
      if (!((this.row != null) && (this.col != null))) {
        t = this.grid.ants.length + 1;
        this.row = Math.floor((t * Math.sin(t) + 50) / 100 * this.grid.rows);
        this.col = Math.floor((t * Math.cos(t) + 50) / 100 * this.grid.cols);
        return this._saveInitialState();
      } else if (!this.grid.isInBounds(this.row, this.col)) {
        throw Error('unimplemented');
      }
    };

    return Ant;

  })(root.EventDispatcher);

}).call(this);
